/**
 *
 *   Copyright 2020 American Express Travel Related Services Company, Inc.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *   in compliance with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software distributed under the License
 *   is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 *   or implied. See the License for the specific language governing permissions and limitations under
 *   the License.
 */

package com.americanexpress.bloom.config;

import com.americanexpress.bloom.constants.Constants;
import com.americanexpress.bloom.constants.ErrorCodes;
import com.americanexpress.bloom.exceptions.BloomException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

/**
 * loads tableDetailsConfig.yml file into java bean
 * and contains mapping on input data columns to memsql table columns
 */
public class MemSQLTableConfig implements Serializable {
    private static final Logger LOGGER = LogManager.getLogger(MemSQLTableConfig.class);
    private static final String tableDetailsConfig = "tableDetailsConfig.yml";
    private final String[] validKeysInYmlFile = new String[]{"tableName", "columnNames", "primaryKeyColumnNames", "timestampColumnName", "mandatoryUpdateColumnNames", "autogeneratedColumnNames"};
    private final List<String> validKeysInYmlList = Arrays.asList(validKeysInYmlFile);
    private Map<String, String> tableDetailsMap;
    private List<String> hiveTableColumnNames;
    private List<String> inputMemSQLTableColumnNames;
    private List<String> memSQLColumnNames;
    public MemSQLTableConfig(CommandLineConfig commandLineConfig) throws BloomException {
        Yaml yaml = new Yaml();

        String srcPath = String.format("%s/conf/", System.getProperty(Constants.APP_HOME));
        File tableYamlFilePath = new File(srcPath, tableDetailsConfig);
        LOGGER.info("Loading table configurations from yml file::{}", tableYamlFilePath);
        InputStream yamlInputStream = null;
        try {
            yamlInputStream = new FileInputStream(tableYamlFilePath);
            Map<String, List<Map<String, String>>> tableDetails = yaml.load(yamlInputStream);
            List<Map<String, String>> tableDetailsList = tableDetails.get("tableDetails");
            for (Map<String, String> tableDetailMap : tableDetailsList) {
                if (tableDetailMap.get("tableName") != null && tableDetailMap.get("tableName").equalsIgnoreCase(commandLineConfig.getTableName()))
                    this.tableDetailsMap = tableDetailMap;
            }
            if (tableDetailsMap == null) {
                throw new BloomException("TableName not configured in the yml file. ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
            }
            if (commandLineConfig.getInputType().equalsIgnoreCase("hive")) {
                generateInputHiveMemSQLColumns();
            }
            String[] configuredKeyInYml = this.tableDetailsMap.keySet().toArray(new String[this.tableDetailsMap.keySet().size()]);
            if (!validKeysInYmlList.containsAll(Arrays.asList(configuredKeyInYml)))
                LOGGER.error("Valid keys for tableConfigYml.yml file are - {tableName,columnNames,primaryKeyColumnNames,timestampColumnName,mandatoryUpdateColumnNames,autogeneratedColumnNames}", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
        } catch (FileNotFoundException e) {
            LOGGER.info("File Not found {}", e.getMessage());
        }
    }

    public List<String> getInputMemSQLTableColumnNames() {
        return inputMemSQLTableColumnNames;
    }

    public void setInputMemSQLTableColumnNames(List<String> inputMemSQLTableColumnNames) {
        this.inputMemSQLTableColumnNames = inputMemSQLTableColumnNames;
    }

    public List<String> getHiveTableColumnNames() {
        return hiveTableColumnNames;
    }

    public void setHiveTableColumnNames(List<String> hiveTableColumnNames) {
        this.hiveTableColumnNames = hiveTableColumnNames;
    }

    public String getMemSQLTableName() throws BloomException {
        String tableName = this.tableDetailsMap.get("tableName");
        if (tableName != null && !tableName.isEmpty()) {
            LOGGER.debug("TableName obtained from yml file is " + tableName);
            return tableName;
        } else
            throw new BloomException("TableName is not configured in the yml file. ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
    }

    public List<String> getMandatoryUpdateColumnNames() throws BloomException {
        String mandatoryUpdateColumnNames = this.tableDetailsMap.get("mandatoryUpdateColumnNames");
        if (mandatoryUpdateColumnNames != null && !mandatoryUpdateColumnNames.isEmpty() && !mandatoryUpdateColumnNames.equals("")) {
            mandatoryUpdateColumnNames = mandatoryUpdateColumnNames.replaceAll("\\s", "");
            LOGGER.debug("mandatoryUpdateColumnNames obtained from yml file is " + mandatoryUpdateColumnNames);
            List<String> mandatoryUpdateColumnNamesList = new ArrayList<String>(Arrays.asList(mandatoryUpdateColumnNames.split(",")));
            if (mandatoryUpdateColumnNamesList.size() > 0) {
                if (!memSQLColumnNames.containsAll(mandatoryUpdateColumnNamesList)) {
                    throw new BloomException("mandatoryUpdateColumnNames do not have valid column names configured in the yml file ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
                }
                List<String> primaryKeys = getMemSQLTablePrimaryKeyColumnNames();
                String timeStampColName = getMemSQLTableTimestampColumnName();
                for (String primaryKey : primaryKeys) {
                    if (mandatoryUpdateColumnNamesList.contains(primaryKey))
                        throw new BloomException("Primary keys cannot be part of the mandatoryUpdateColumnNames in the yml file ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
                }
                if (mandatoryUpdateColumnNamesList.contains(timeStampColName)) {
                    throw new BloomException("Timestamp columns cannot be part of the mandatoryUpdateColumnNames in the yml file ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
                }

            }
            return mandatoryUpdateColumnNamesList;
        } else
            return null;

    }

    public List<String> getMemSQLTableColumnNames() throws BloomException {
        String columnNames = this.tableDetailsMap.get("columnNames");
        if (columnNames != null && !columnNames.isEmpty() && !columnNames.equals("")) {
            columnNames = columnNames.replaceAll("\\s", "");
            this.memSQLColumnNames = new ArrayList<String>(Arrays.asList(columnNames.split(",")));
            return this.memSQLColumnNames;

        } else
            throw new BloomException("columnNames not configured properly in the yml file. ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);

    }

    public List<String> getMemSQLTablePrimaryKeyColumnNames() throws BloomException {
        String primaryKeyColumnNames = this.tableDetailsMap.get("primaryKeyColumnNames");
        if (primaryKeyColumnNames != null && !primaryKeyColumnNames.isEmpty() && !primaryKeyColumnNames.equals("")) {
            return Arrays.asList(primaryKeyColumnNames.split(","));
        } else
            throw new BloomException("primaryKeyColumnNames not configured properly in the yml file. ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);

    }

    public String getMemSQLTableTimestampColumnName() throws BloomException {
        String timestampColumnName = this.tableDetailsMap.get("timestampColumnName");
        if (timestampColumnName != null && !timestampColumnName.isEmpty() && !timestampColumnName.equals("")) {
            return timestampColumnName;
        } else
            throw new BloomException("timestampColumnName not configured properly in the yml file. ! ", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);

    }

    public List<String> getMemSQLTableAutogeneratedColumnNames() {
        String autogeneratedColumnNames = this.tableDetailsMap.get("autogeneratedColumnNames");
        if (autogeneratedColumnNames != null && !autogeneratedColumnNames.isEmpty() && !autogeneratedColumnNames.equals("")) {
            return Arrays.asList(this.tableDetailsMap.get("autogeneratedColumnNames").split(","));
        } else {
            LOGGER.info("No autogenerated columns present for this table", ErrorCodes.MBL_TABLE_CONFIG_PARSING_FAILED);
            return new ArrayList<>();
        }
    }


    public void generateInputHiveMemSQLColumns() throws BloomException {
        String hiveMemSQLColumnsMapping = this.tableDetailsMap.get("hiveMemSQLColumnsMapping");
        List<String> hiveTableColumnNames = new ArrayList<String>();
        List<String> memSQLTableColumnNames = new ArrayList<String>();
        LOGGER.debug("hiveMemSQLColumnsMapping obtained from yml file is " + hiveMemSQLColumnsMapping);
        if (hiveMemSQLColumnsMapping != null && !hiveMemSQLColumnsMapping.isEmpty() && !hiveMemSQLColumnsMapping.equals("")) {
            hiveMemSQLColumnsMapping = hiveMemSQLColumnsMapping.replaceAll("\\s", "");
            for (String hiveMemSQLCol : hiveMemSQLColumnsMapping.split(",")) {
                if (hiveMemSQLCol != null && !hiveMemSQLCol.isEmpty() && !hiveMemSQLCol.equals("")) {
                    String[] hiveMemSQLColArray = hiveMemSQLCol.split(":");
                    hiveTableColumnNames.add(hiveMemSQLColArray[0]);
                    memSQLTableColumnNames.add(hiveMemSQLColArray[1]);
                }
            }
            setHiveTableColumnNames(hiveTableColumnNames);
            setInputMemSQLTableColumnNames(memSQLTableColumnNames);
        } else
            throw new BloomException("hiveMemSQLColumnsMapping not configured properly in the yaml file. ! ");

    }
}

